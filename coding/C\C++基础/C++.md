## 虚析构函数

> 当用基类指针指向子类对象指针时，释放析构函数，只会调用基类自身的析构函数，若将其定义为虚析构函数，则先会调用子类的析构函数，再调用子类的析构函数。

## explict
  
 explict可以避免不合时宜的类型转换，CxString  string1(24);和CxString string2 = 10;都可以，是因为当类的构造函数只有一个参数时，编译时会有一个缺省的转换操作，将构造函数对应类型的数据转换成该类的对象。

 下面若不声明 explict ，则编译通过，因为他生成了 CxString(24)的对象，并通过拷贝构造函数生成了 string1。
 
 若声明 explict 则第二个会报错，

 ```
 CxString string1(24);
 CxString string1 = 24;
 ```

 ## override

确认覆盖基类的虚函数，

有三种作用：

1. 做注释用，方便代码阅读
2. 验证是否重写了父类的虚函数，若不为虚函数则报错

## inline

将函数翻译成代码段，避免发生函数跳转，提高运行速度。

### 注意

声明了内联的函数不一定内联，可以将该关键字作为意图的表达，而不用在意其是否内联。
静态函数也可以内联，但其是否内联生效则值得商榷。