## 虚析构函数

> 当用基类指针指向子类对象指针时，释放析构函数，只会调用基类自身的析构函数，若将其定义为虚析构函数，则先会调用子类的析构函数，再调用子类的析构函数。

## explict
  
 explict可以避免不合时宜的类型转换，CxString  string1(24);和CxString string2 = 10;都可以，是因为当类的构造函数只有一个参数时，编译时会有一个缺省的转换操作，将构造函数对应类型的数据转换成该类的对象。

 下面若不声明 explict ，则编译通过，因为他生成了 CxString(24)的对象，并通过拷贝构造函数生成了 string1。
 
 若声明 explict 则第二个会报错，

 ```
 CxString string1(24);
 CxString string1 = 24;
 ```

 ## override

确认覆盖基类的虚函数，

有三种作用：

1. 做注释用，方便代码阅读
2. 验证是否重写了父类的虚函数，若不为虚函数则报错

## inline

将函数翻译成代码段，避免发生函数跳转，提高运行速度。

### 注意

任何函数都可以声明内联，因为类的成员函数也只是传入了this指针的普通函数，他们在内存中的存储位置都是一样的，所以编译器并不会对他们做差别处理。

声明了内联的函数不一定内联，即内联只是对编译器的一种建议。可以将该关键字作为意图的表达，而不用在意其是否内联。

静态函数也可以内联，但其是否内联生效则值得商榷。


### 数组引用 和 引用数组

#### 引用数组

即一个包含众多引用的数组。是没有任何意义的。
**原因:**
1. 因为引用不好直接初始化, 只能对其内部的元素逐个拷贝。
2. 当在函数内要对这个引用数组整体拷贝时，无法整体实现，必须要对其内部的元素一个一个拷贝。
