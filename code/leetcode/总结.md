# leetcode知识总结

## 原则
1. 不要畏惧写空间和时间复杂度较高的代码，先出结果，后面可以慢慢优化。

## 思考
1. 取中位数时，可以先将所有的数排序好，在来求取中位数，
2. 多数求和的时候，可以先排序，然后就只用遍历临界点之前的数。
3. 分类的时候， 若种类不多， 可以将一种放在最前，一种放在最后，就自动分类完毕了。
4. 当要获取倒数的节点时，可以使用两个前后指针，同步向后移动，后指针移动到最后时，前指针就移动完毕了。
5. 在不同的场景可以使用利用容器的特性，比如栈（后入先出）、队列（先入先出）、set（排序和去重）
6. 写链表时，当想用last记录上一次的位置时，当首次执行时，可以新建一个节点作为head的虚拟头节点，就不用对第一次运行做特别的判断了。
7. 做链表递归反转的时候，子结点的任意改变都不会影响到父节点，因此子链表任意反转，而父节点指向的指针地址是固定的,所以反转链表可以直接通过node->next找到子结点。
8. 消消乐型的题目可以使用栈。
9. 若要多次用到数组中的某个元素，最好用中间变量获取它的值，不然 `s.push(s[i])` 中， s[i] 经常被忘掉。
10. 在一个区域内，求取最大或者最小值，都可以使用优先队列的方式，也就是大根堆、或者小根堆。
11. 当对字符串处理时，若需要使用到 栈、队列、向量之类的操作，可以通通使用 `std::string` 类来代替。
12. 做树的对称比较的时候，只需要判断两个节点的左右子树是否对称。


## 递归
> 递归的本质： 一个问题能调用自身一个或规模较小的子函数来执行，一个子函数中可能包含多种情况的自身的子函数调用。 
编写递归函数主要思考3个方面。
* 函数（包含入参和返回值）
* 递推公式（比如f(n) = f(n-x) 或者 f(n) = f(n-1) + f(n-2)）
* 终止和异常条件。

入参刚开始会考虑不全，没关系，只要想好终止条件就行了，递推公式可以通过数学公式推导。\
不要试图去理解递归的每一层调用，一个公式对f(1)和f(0)生效，我们就有理由认为它对别的公式也生效。\
对于树类型，递归永远要两次调用自身，分别表示左子树和右子树，且返回值永远是一个树节点。


### 反转链表 

**考虑入参和返回值**: \
返回值： 已反转的子链表。\
传入值： 子链表的头节点

**终止条件**:\
当子链表的下个节点为空的时候

**递推公式**:\
将子链表反转，因为返回值是已翻转的子链表，所以只需要根据返回值做翻转即可。\
将每次递归的传入节点都当作是整条链的头节点，不要考虑和上个节点之间的关系。 


## 寻找两个正序数组地中位数
1. 取中位数时，可以先将所有的数排序好，在来求取中位数，适合那些中位数的取值个数不确定的情况。
2. 取中间的数的时候，有三种方法.
   * 合并（推荐）
   * 索引递增
   * 二分法

## 三数之和
**降低时间复杂度**：
1. 核心原理是，先取出第一个元素，然后剩下的数组中找出两个组合，但是找组合是有技巧的，可以考虑去重。
2. 先排序。若中间排列组合不能重复时，则当前元素和上个元素相等的时候直接退出。
3. 先排序，然后使用滑动窗口的方法，将指针指向最后一个，慢慢减少，比直接从头开始一个个比较要快。


## 颜色分类
1. 分类时将一种移到前面，一种移到后面，就排序成功，当移动后的结果为要移植的值就需要回退。
2. 若顺序调整前两种，调整第一种后，第二种的索引也要加1，

## 最小覆盖字串
1. 找字符串类型优先可以使用滑动窗口，在一个区域内限制。
2. 分解步骤，比较复杂的步骤，可以单独在一个函数中实现。
3. 不要害怕算法超时，各种while循环大胆的写，能出来结果就行。

## 删除链表的倒数第 N 个结点
1. 最简单的方式就是删除、翻转、再删除。
2. 使用前后指针，后指针移动到末尾的时候，前指针刚好移动到目标节点。
3. 可以利用栈的特性，后入先出。

## 两两交换链表中的节点
1. 使用普通的迭代法，即分别用两个指针指向要交换的节点，每次交换完成前向后挪两步，并通过last与前一个交换的尾节点连接
2. 使用递归的方法，递归函数的单次执行，就是交换最后面的头节点和尾节点，并将新的尾节点教给上一层递归执行。

## 环形链表
1. 快慢指针
2. while循环的退出条件有两种选择，一种是快指针为 NULL, 还有一种是快慢指针碰撞了，使用哪种都可以，但是不要在循环里面有重复的if判断，显得很冗余，从而不够美观。

## 环形链表2
1. 求链表的入环点可以通过快慢指针。
2. 快慢指针碰撞点是和指针出发的起始位置密切相关的，因此两个指针必须同时出发。

## 设计链表
1. 当想要从尾部直接操作时，最好设计双向链表。
2. 单链表只适合从头部开始操作。

## 有效的括号
1. 当需要消消乐配对的时候，最好使用栈，因为栈是后入先出。

## 滑动窗口求最大值
1. 使用优先队列的方式。因为滑动窗口的区间是固定的，因此一个最大值能映射的范围是固定的，当出了这个范围，就需要重新找在这个范围内最大值。
2. 使用单调队列的方式，使用队列存储一个单调递减队列的下标，当插入一个元素时，逐渐和前面下标对应的元素做比较，小的队尾元素则删除。因为是单调的，所以 \
   头部的元素是最大的，在判断头部的下标是否在 i-k 这个范围内，不在则逐渐剔除头部的元素，直到找到这个范围内的最大值为止。

## 第k大元素
1. 使用小根堆的方式，当堆中只保留k个元素，则堆顶的元素，就是最小的，也就是第k大。

## 删除字符串中的所有相邻重复项
1. 最容易想到是栈，但是用栈还得手动拼接字符串，因此会超时。
2. 可以使用string, string 自带双向队列的操作。

## 反转字符串（不借助额外空间）
1. 头部和尾部的索引想加等于 n-1，所以只需要两两交换 s[i] 和 s[n-1-i]   

## 四数之和
1. 就是三数之和上面在嵌套一层。
2. 要考虑int越界的问题。

## 字母异位词分组
1. 将单词排序，做 `map` 的键。
2. 对字母出现的次数计数，用作map的键，写法比较复杂，不推荐。

## 有效的字母异位词
1. 使用 sort 排序在比较，
2. 使用map或者vector<int>(26,0)， 先计算一个单词字母的个数，然后逐个比较另一个单词。

## 二叉树中序遍历
1. 推入值只能推一次，在 midorder(root->left); 后面接入推值的语句。

## 对称二叉树
1. 使用递归的方法，传入两个节点，将其中一个的左结点和另一个的右节点做比较，不相等则退出。
2. 使用迭代的方法，使用队列存储，先推入1号节点的左节点，再推入2号节点的右节点，再推入1号节点的右节点，再推入2号节点的左节点。

## 二叉树的层序遍历
1. 使用队列存储每一层的节点，若要将层级的节点分开， 可在这次遍历之前获取这次要推入的个数，或者是用另一个队列存储新增的层级节点。

## 二叉树的垂序遍历
1. 使用列、行、值的顺序进行排序。
2. 可以使用 tuple 代替两层 map。

## 二叉树的最大深度