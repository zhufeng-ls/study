# 设计模式

阅读要素:

1. 阅读设计模式时，总结： 名称、问题、解决方案、效果
2. 组合大于继承
3. 23种设计模式



原则:

1. 设计模式只是常见问题的通用的可重用的解决方案。

注意：

* 设计模式并不是解决所有问题的灵丹妙药
* 不要强行使用设计模式
* 不要过度使用设计模式

类型：

* 创建型
* 结构型
* 行为型

# 创建型

- [简单工厂模式（Simple Factory）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-simple-factory)
- [工厂方法模式（Factory Method）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-factory-method)
- [抽象工厂模式（Abstract Factory）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-abstract-factory)
- [建造者模式](https://github.com/3rdStudy/design-patterns-for-humans-cn#-builder)
- [原型模式（Prototype）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-prototype)
- [单例模式（Singleton）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-singleton)

# 工厂

> 工厂方法的核心就是解耦，即当我们需要调用更改调用的类时，只需要更改工厂内部所创建的类，而不用挨个替换。

## 简单工厂

简单工厂的应用场景就是返回一个类的实例对象，它将类的实现和类的调用相分离，用户通过工厂类来调用实现类，而不用关心它的实现，在一定程度上有解耦的作用。

>  但是当增加新的子类时，工厂类也要做相应的修改，违背了开闭原则。

问题:  当需要使用某种类型的不同实现时，比如安装不同类型的门，

解决方案： 根据接收参数的不同，使用一个工厂类或者静态函数来创建某个门的实例对象，即工厂类把某种基类的子类全部划分到这一个工厂类中来创建， 。

效果: 通过一个工厂类来选择我们需要的门。

## 工厂方法

工厂方法的应用场景是： 在不指定这个对象的具体类型来创建类，即工厂类有很多工厂子类，为每个产品提供一个工厂子类。当创建一个新的产品时，只需要实现产品子类和创建新的工厂子类，而不用修改产品基类和工厂基类，完全符合开闭原则。

> 对象调用者需要与工厂子类耦合，因为这个工厂子类是单独只提供这一个产品的，因此切换产品，就必须更换工厂子类。
>
> 代码工作量太大。
>
> 当产品类修改的时候，工厂类也要进行修改，不易于维护。

问题: 当我们需要创建某个具体类型的对象，但是不希望指定它的类型。

解决方案: 为每个产品创建一个工厂类，当需要这个产品时，只需要调用这个产品的工厂类来获取这个产品的实例对象。

效果: 每个产品通过具体的工厂类来调用，当增加新产品时，不会违背类的开闭原则。

## 抽象工厂

工厂方法是创建某一种产品，而抽象工厂是创建某一类别的产品。

也可以理解为工厂方法的工厂，若要将上述某几种产品划分为一类，则将产品的工厂子类用新的工厂类来包含。

> 可以增加新的产品归类，难以扩展抽象工厂来增加新的产品。

问题: 子类比较多的时候，当我需要自由地把某些菜进行类别划分的时候。

解决方案:  可以将菜的工厂子类进行随意组合，划分成一个个新的类目。

效果:  友好的分类。

使用场景： 当涉及到不那么简单的，存在相互依赖关系的创建逻辑时使用。


## 建造者模式

当构造函数传入的参数过多的时候，即避免伸缩构造函数反模式，则使用一个Builder类来接收所有的参数，并传入这个Builder类的对象作为产品的构造函数的参数。比如汉堡定制，加什么类型的酱汁、什么样的奶油。

问题: 构造函数参数过多。

解决方案: 使用建造者类作为参数接收的中间类。

效果:  类的参数简洁了许多

使用场景：当一个对象可能存在好几种类型且避免构造函数伸缩时使用。与工厂函数的区别在于：当创建是一步过程时，使用工厂模式，当创建是多步过程时，使用建造者模式。


## 原型模式

允许通过克隆现有对象来进行修改，而不用从新开始创建对象并设置

问题: 创建新对象的成本较高

解决方案: 通过成员函数来 clone出新的对象

使用场景：当需要一个和现有对象类似的对象，且创建新对象的成本比 clone更高。

## 单例模式

全局只存在一个对象。

> 单例模式是一种反模式，应该避免过度使用它，它在你的应用程序中引入了一个全局状态，并在一个地方更改可能会影响到其他地方，变得非常难以调试，关于它们的另一个坏处是使你的代码更加耦合。



# 结构型设计模式

通俗解释:

> 结构模式大多关注对象组成，换句话说，实体如何相互调用。或者说 "如何构建软件组织" ？

分类:

- [适配器模式（Adapter）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-adapter)
- [桥梁模式（Bridge）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-bridge)
- [组合模式（Composite）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-composite)
- [装饰模式（Decorator）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-decorator)
- [门面模式（Facade）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-facade)
- [享元模式（Flyweight）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-flyweight)
- [代理模式（Proxy）](https://github.com/3rdStudy/design-patterns-for-humans-cn#-proxy)



## 适配器模式

将一种对象转换成另一种接口可以识别的对象

问题: 当另外一种设备需要接入电脑时，却没有相应的接口。

解决方法: 创建一个具体的适配器类，适配器类继承于接口，并在适配器内部是被另外一种设备的接口抽象。



## 桥梁模式

将抽象部分和实现部分相分离，使它们在自己的维度上有多维度的变化。

问题：比如更换某软件的主题。

解决方案: 创建软件类和主题类，软件类运行时，传入主题类。

效果: 达到更换主题的目的，并将主题类从软件类中抽离出来，单独在外部自己实现。



## 组合模式

描述了一组对象的处理方式与单个实例对象相同，即允许客户以统一的方式处理单个对象和组合。

实现方式： 一个管理类以相同的方式处理不同类型的对象，如一个部分内可以招聘不同工种的员工。


## 装饰模式

在不改变原来的类的前提下，为它增加新的职责。

问题: 当增强或扩充新功能的时候， 若是使用继承的方式增加子类，则组合新的功能时，子类会成排列组合式的增加。

实现: 传入原来的对象、输出增加了新职责的新装饰器对象，就像是月饼的包装纸一样，可以一层一层地包起来。

和桥接模式的区别:

1. 桥接模式是在一个接口里通过构造函数查传入另一个接口的实现，并可以在类中调用这个类的实现。
2. 装饰器则是使用另一个类来包装自己的功能，可以一直叠加。


## 门面模式

将复杂的底部操作抽象出来。

和接口的区别: 

1. 对接口的实现类进行再次封装，暴露出简易的接口


## 享元模式

最大化的共享资源，节省空间和时间。

实现方法: 一个资源的创建类，一个资源的调用类，调用类调用创建类时，若资源已创建，则返回该资源，否则就创建新的资源并返回。


## 代理模式

当我们需要实现某个动作时，可以有多种方式， 如开门，可以使用钥匙或门禁卡，则门禁卡就是代理的类。

代理最一般的形式，是一个充当其他东西的接口的类，通过某个代理的对象访问幕后的对象就是代理模式。



# 行为型设计模式

在软件工程中，行为设计模式是识别对象之间的共同通信模式并实现这些模式的设计模式。通过这样做，这些模式增加了执行该通信的灵活性。

* 责任链模式（Chain Of Responsibilities）
* 命令行模式（Command）
* 迭代器模式（Iterator）
* 中介者模式（Mediator）
* 备忘录模式（Memento）
* 观察者模式（Observer）
* 访问者模式（Visitor）
* 策略模式（Strategy）
* 状态模式（State）
* 模板方法模式（Template Method）


## 责任链模式

构建一系列对象，头部的优先级最高，从头到尾，直到找到符合条件的，则责任链破裂。


## 命令行模式

允许您将操作封装在对象中。这种模式背后的关键思想是提供将客户端与接收器分离的方法。

例如开关机，分别将开机和关机两个动作封装成两个类。客户端通过调用参数为开关机命令的函数，从而达到开关机的目的。


## 迭代器模式

是一种遍历容器并访问容器的方法，如收藏的音乐，收音机调频。


## 中间者模式

Mediator 模式添加第三方对象（称为中介者）来控制两个对象（称为同事）之间的交互。它有助于减少彼此通信的类之间的耦合。因为现在他们不需要了解彼此的实现。


## 备忘录模式

备忘录用来记录和存储对象的状态，以便平滑的恢复。

需要有一个恢复的对象，来存储保存的内容，恢复就是还原这个对象的内容


## 观察者模式

一个目标类，多个观察者，当目标类改变后，通知所有的观察者。


## 访问者模式

将需要访问的对象的方法都实现，然后传入到对象，对象调用你实现的方法，有点像多个函数指针的组合。


## 策略模式

策略模式可以允许你通过情况来选择算法，比如大的算法集使用快速排序，小的算法集使用冒泡排序。

看原理好像是抽象出排序的接口，实现类为快速排序类和冒泡排序类，然后根据情况使用。


## 状态模式

通过同一个状态接口来实现的不同的状态，并通过状态的超类定义的方法来进行状态的切换(有切换方法的基类不叫接口，接口是没有任何具体的实现的)


## 模板方法模式

先定义好这个算法的框架，然后将其实现推迟到子类。







