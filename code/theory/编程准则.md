# 编程技巧和准则
## 提高编程能力
1. 当程序编译或者运行报错的时候，一定要先自己理解错误的字面意思，尝试自己解决，未果后在google搜索，这样可以提高自己分析问题的能力.
2. 当程序编译或运行未达到预期结果时,先自己阅读下源码,尝试找到解决问题的办法,不要遇到问题就知道google.
3. 当对模块进行测试时,要一点一点的测试,不要太着急写完代码,写完代码后的测试效率太低.
4. 心态要放平缓,不要着急完成工作,当解决一个问题时,先从结构方面思考有什么可以方便后面进行调试的写法.
5. 遇到自己习以为常却运行错误的情况，在尝试后无果后，一定要记得上网搜索资料，搜索的时候要客观，不要搜索错误，而是搜索自己想这样做的原因。

## 阅读代码
1. 阅读代码要bfs，一个文件一个文件的看，中间有用到其他文件的函数时，只需要了解它的作用，而不要横向拓展去了解它的实现。

## 提高工作效率
1. 当用到不熟悉的库时，一定要完整的读一遍示例，不要自己动手一点一点的实验，浪费时间

## 编写代码
1. 编写代码时，不要想着节省空间，提高运行速度，即堆空间的申请，要大胆， 不要害怕堆空间申请失败，记得释放就行。
2. 不要做无意义的消息填充，没有意义的消息在发送端就应该处理了，不要等着消费线程处理。
3. 复杂的类要编写测试用例，每个类用一个测试文件，最后将所有的测试文件编入一个二进制，可参考`ipush`项目。
4. 一些即用类，如日志和时间类，应该由自己初始化，而不是外部调用类初始化，调用类直接调用其接口就可以了。
5. 使用事件来分别表示功能，当增加某个功能的时候，只需要增加对应的事件接口，而不用修改类内部的细节。（问题是，当有很多地方用到这个事件，每个用到这个事件的地方都要增加一个 if 判断）。
6. 当修改功能时，看修改的代码量多不多。
   1. 若比较大的时候，可以将修改的部分提取到另一个函数中，包括 if 判断和 while 循环。
   2. 包括若不大时，直接在上面进行修改。
7. 当新增一个业务功能时，这个功能的初始化和启用应该放在哪里？
   1. 逐步寻找它的上级，看它跟什么模块相关，放在它的最小上级模块中
8. 根节情况使用 if 判 true 或 false, 哪个调用的次数多就放在前面，若都相同，则判 true, 便于理解。
9. 多增加一个if判断和多赋值一次，哪个更节省资源，初步认为是 if 判断。
10. 代码怎么布局好看就怎么放置，不用死脑筋强行按规则， 比如一个变量的定义是放中间还是放前面，哪个更适合阅读，看的更顺眼，就放在哪里。
11. 在 if 判断中, `!` 配合 `||` 和 `<` 使用, 而 `&&` 配合 `>`. `==` 和 `!=` 视情况而定.
12. while 循环的退出条件，可选择的余地有：
    1. 判断它是否完成目标。 
    2. 判断它是否到了尾端。
13. 刷算法题时，碰到不理解的代码块，要把它单独提出来，理解它的作用。
14. 当改变量名或者参数值的时候，在时间充足的情况下，最好阅读当前函数所有的代码，以便检查错误和加深理解。
15. 不要直接推送数据到队列中，使用函数封装数据，同一类的消息使用一个函数封装，大类不同的消息使用不同的函数封装，因为都使用一个函数封装，后面更改某一类的消息时，就会变得难以理解。
16. 永远不要直接修改别人的代码, 不然不好分锅, 在别人的代码里面嵌入自己的逻辑时, 一定要以函数接口的形式
17. 一类业务功能的代码, 一定要在一个文件内进行, 不要图方便, 分散开来, 可以使用接口函数的方式层层往外传. 
18. 每个可执行文件的目录都要有个CMakeLists.txt，做到严格的分离，一个CMakeLists.txt只管它自己的目录，而不用管它的子目录。
19. 跳外部接口请求的时候，对请求值解析需要做异常捕获。解析异常的时候，往外抛出异常。
20. 配置文件和日志单独放在一个目录，这样部署在docker里面时，方便做映射
21. 刷不懂的算法时，碰到不懂的地方，且不影响后面文档的阅读，则先跳过它，等看完整体流程在回过头来理解，比如红黑树`父红叔黑`的状况。
22. 重置状态变量最好使用一个函数来代替，就算它只有一行代码。
23. 当网上的帖子表述不清楚时，尝试找相关的代码进行理解。
24. 除数为变量时，一定要做非0判断。
25. 每更改一个地方做测试时，都要写上`TODO`进行标记, 方便后续恢复。 
26. 在编程的时候，不要考虑那些极端的情况，比如 `init()`初始化函数调用了两次，等等这种，若要避免这种情况，可以直接使用 `assert` 断言。
27. 对那些极少发生的错误，可以使用断言，避免加锁失败等操作。
28. 若要执行一些初始化的操作，可以将初始化的操作封装到 xxxInitializer 类的构造函数中， 然后创建这个类的全局变量。
29. 当类型名过长的时候，可以使用 typedef 缩短， 不要害怕使用 typedef, 并不会影响性能。 
30. 保存配置文件，当且仅当软件支持用户在线更改配置时，其余的情况对配置文件只读取或者生成，而不做写入。
31. 当和别人联调时，发步自己的程序时，将自己软件的md5编码也一并发布出去，避免扯皮。
32. 当别人说它的程序没问题时，让它把它完整的包发过来，包括它说没有改的地方。
33. 不要在函数外部给全局变量申请堆空间
34. 全局变量可以封装成类的静态数据成员
35. 类中申请的动态区域需要在程序结束后释放，可以使用 RAII 技法，创建一个子类，将动态区域的指针传递到静态子类对象中，当程序停止运行后，则开始销毁静态对象
36. 当使用智能锁时，可以使用 `{}` 来限制它的范围
37. 类的成员变量定义的顺序也需要注意，要和构造函数外部初始化的顺序保持一致。
38. 将操作符重载放在命名空间里，可读性更高。
39. 模板类的数组大小可以通过传入 `int size` 作为模板参数来控制
40. 使用智能指针获取文件类的对象时，可以通过 reset() 来调用对象内部的析构函数，从而关闭文件描述符，并接入新的文件描述符（‘’），这在日志文件中非常好用。 
41. 在析构函数中停止或者是否对象时，一定要先判断是否为空，避免对象意外释放导致错误。 还有一层原因就是，不用在 stop() 里面判断状态了，只需要在调用 stop() 之前判断， 这样更直观一点。
42. 尽量将不同的模块拆分成不同的库，这样改动一个地方时就不用重新链接所有的 .o 文件， 改代码后，也可以只替换对应的库。
43. 对 enum 枚举设置字符串时，最好用一个函数来输出， 例如 `methodString()`, 这样就不用考虑数组初始化的问题。
44. .h 中只应该包含比如必要的声明，比如 base库的内容，或者只有一个 .h 文件的内， 而 net 库的头文件应该放在 .cc 中。

### 待定
1. 待定（当使用某个工厂类的时候，工厂类的构造函数接收某个枚举变量，这样根据枚举就可以确定调用哪个构造函数了。）

### 解耦

> 模块之间互相独立，一个模块崩溃不会导致另一个模块崩溃。

方法: 
1. 模块之间独立，功能模块可以做成二进制程序，并开放对应的接口，这样上层模块就只需要调用二进制程序，当功能模块的业务改变时，只需要重新生成接口程序，而保持接口不变，就不会影响到上层模块。