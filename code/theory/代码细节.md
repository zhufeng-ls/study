## 代码细节

### if 逻辑判断

== 用于正确的情况

!= 用于异常的情况

### 构造函数后面接参数

若初始化基类的成员，则必须要在构造函数体内初始化

### 命名空间
1. 命名空间最好只在函数中引用。
2. 测试用例和示例中可以使用全局的命名空间

### switch

case 后面要接 {}, 表示作用域。

### 指针互转一定要注意.
错误情况: \
1. 包含std::string类型的结构体，使用 std::string强行转换。（结构体的内存布局）
2. char* 直接强转为 string*

### 堆空间申请
1. 申请的空间由处理函数释放，因为类似于生产者，对象推入队列中不一定马上处理，所以只能等待消费者释放


### 头文件中定义const常量和static变量
> 引用头文件相当于将头文件的所有内容全部拷贝到源文件中。 

**c**:\
1. 在头文件中定义static，可以编译通过，相当于在每个源文件中定义一个只存在于当前文件中的静态变量。
2. 在头文件中定义const， 编译不通过， 会显示重复定义。

**c++**:\

**全局变量**:\
1. 头文件中的数组一定要加const, 不然会显示重定义。
2. 头文件中定义static, 和 c 情况一致。
3. 头文件中定义const, 可以编译通过，但是会重复构造，造成不必要的内存浪费。

**类中**:\
1. 类中使用`const int size = 200;` 是错误的，因为对象未创建时，不知道const 是什么。\
   所以需要使用 `enum {SIZE = 200}; int array[size]`的方法来表示常量，但是enum默认是int, 能表示的数据空间有限。
2. const 数据成员的初始化能且只能在构造函数中进行。
3. 可以使用 `static const int size = 200`, static 表明在内存中只有一份，被整个类共享，且存储在全局数据区， const 表明它是一个常量，值不可以改变。

**总结**:\
1. 不要在头文件中定义const 或 static 常量， 定义在源文件，头文件中使用 extern 引用。
2. 类中定义的全局变量，需要加上static, 表示在内存中只有一份。


### 遍历字符串
判断条件不要使用`i < strlen(str)`或者 `i < str.size()`, 因为str的长度可能是实时变化的，所以系统每次都会遍历一次str,复杂度由 O(n) 变为了 O(n^2).

**错误的写法**: \   
```c
char *str = "abcde";
for (int i = 0; i < strlen(str); ++i)
{
    // do something
}
```

```c++
std::string str = "abcde";
for (char s : str)
{
    // do something
}
```

**正确的写法**:\
```c++
char *str = "abcde";
int n = strlen(str);
for (int i = 0; i < n; ++i)
{
    // do something
}
```