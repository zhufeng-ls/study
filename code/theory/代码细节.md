## 代码细节

### if 逻辑判断

== 用于正确的情况

!= 用于异常的情况

if 左值为传入的参数，右值为待比较的值，比较符合人的思维习惯。

### 构造函数后面接参数

若初始化基类的成员，则必须要在构造函数体内初始化

### 命名空间
1. 命名空间最好只在函数中引用。
2. 测试用例和示例中可以使用全局的命名空间

### switch

case 后面要接 {}, 表示作用域。

### 指针互转一定要注意.
错误情况: \
1. 包含std::string类型的结构体，使用 std::string强行转换。（结构体的内存布局）
2. char* 直接强转为 string*

### 堆空间申请和释放
1. 关于new 创建的问题由谁删除的问题，正确回答是由消费函数来进行消费。因为消费函数中可能会有好几个消费者。
2. 一次将其拷贝给给每一个消费者后在进行销毁，不要想着少new，new的空间只存在于一个对象中，当切换对象后，前面所new的空间就要销毁，由后面来创建新的空间。
3. 当new的空间被别的对象封装了一层后，也需要理解销毁当前new的空间，转而在新的对象中重新new。

### 头文件中定义const常量和static变量
> 引用头文件相当于将头文件的所有内容全部拷贝到源文件中。 

**c**:
1. 在头文件中定义static，可以编译通过，相当于在每个源文件中定义一个只存在于当前文件中的静态变量。
2. 在头文件中定义const， 编译不通过， 会显示重复定义。

**c++**:

**全局变量**:
1. 头文件中的数组一定要加const, 不然会显示重定义。
2. 头文件中定义static, 和 c 情况一致。
3. 头文件中定义const, 可以编译通过，但是会重复构造，造成不必要的内存浪费。

**类中**:
1. 类中使用`const int size = 200;` 是错误的，因为对象未创建时，不知道const 是什么。\
   所以需要使用 `enum {SIZE = 200}; int array[size]`的方法来表示常量，但是enum默认是int, 能表示的数据空间有限。
2. const 数据成员的初始化能且只能在构造函数中进行。
3. 可以使用 `static const int size = 200`, static 表明在内存中只有一份，被整个类共享，且存储在全局数据区， const 表明它是一个常量，值不可以改变。 
   
    3.1. 只有`const` 整型变量(整型包括 `bool`、 `char`、 `wchar_t`)和枚举类型可以这么定义，其他的包括 `int 数组`和其他的字符串都只能在类外定义。 \
    3.2. 在类中借助枚举巧妙定义 整形数组。
    ```c++
    class A 
    {
        static const int a = 3;
        enum { arrsize = 2 };

        static const int c[arrsize] = { 1, 2 };

    };
    ```
    3.3. 只允许整型在类中定义的原因是，整型是明确的值，编译器知道它不会被修改。 \
    3.4. 可以使用inline, 它会被翻译成另一个代码段，


**总结**:
1. 不要在头文件中定义const 或 static 常量， 定义在源文件，头文件中使用 extern 引用。
2. 类中定义的全局变量，需要加上static, 表示在内存中只有一份。


### 遍历字符串
判断条件不要使用`i < strlen(str)`或者 `i < str.size()`, 因为str的长度可能是实时变化的，所以系统每次都会遍历一次str,复杂度由 O(n) 变为了 O(n^2).

**错误的写法**: 
```c
char *str = "abcde";
for (int i = 0; i < strlen(str); ++i)
{
    // do something
}
```

```c++
std::string str = "abcde";
for (char s : str)
{
    // do something
}
```

**正确的写法**:
```c++
char *str = "abcde";
int n = strlen(str);
for (int i = 0; i < n; ++i)
{
    // do something
}
```

### 异常
1. 捕获到异常后是可以继续执行异常后面的代码的，而不是会直接退出。